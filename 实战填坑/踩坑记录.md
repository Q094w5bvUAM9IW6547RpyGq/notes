### vue

#### .vue文件，是如何被编译然后运行到浏览器中的

vue-loader作用

- 解析和转换.vue文件，提取出其中的逻辑代码 script,样式代码style，以及HTML模板template，再分别把他们交给对应的loader处理
- css-loader加载由vue-loader提取出的css代码
- vue-template-compiler:把vue-loader提取出来的html模板编译成可执行的javascript代码

#### vue组件中的data为什么必须是个函数

> 每个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data是一个对象的话，那么一旦修改其中一个组件中的数据，其它组件相同数据就会被改变

> 而data是函数的话，每个vue组件的data都因为函数有了自己的作用域，互不干扰

#### vue的生命周期是什么

>  就是vue从开始创建到销毁的过程

> 分为四大部

- 创建

  - beforeCreate
  - created

- 挂载

  - beforeMounte

    - 在beforeMount前，虚拟dom已经创建完成，

  - mounted

    - 之后在mounted前，将vm.$el渲染页面，,mounted将虚拟dom挂载到真实页面（此时页面已经全部渲染完成）

- 更新

  - beforeUpdate
  - updated

- 销毁

  - beforeDestroy

    - 最后函数主动调用销毁函数或者组件自动销毁时beforeDestroy，手动撤销监听事件，计时器等

  - destroyed

    - 仅存在Dom节点，其它所有东西自动销毁

#### vue中key的作用和工作原理

#### 高效的更新虚拟dom

> 其原理是vue在patch过程中通过key可以精准的判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少Dom操作量，提高性能

#### [route和router的区别](https://www.cnblogs.com/ff-upday/p/15507762.html)

#### [父子组件通信](https://www.cnblogs.com/ff-upday/p/15507762.html)

1.父组件通过this.$refs来访问子组件
2.父组件通过子组件定义的props属性结合 v-bind 来传递数据给子组件
3.子组件可以通过`this.$emit`传递事件给父组件，父组件通过v-on来监听

#### Vue.js 监听属性 watch

项目案例：当用户输入事件触发,tableFormTableDataChange数值改变，调用其回调函数

```
data:{
  retrun {
    tableFormTableDataChange: 0
  }
}
watch: {
  'tableFormTableDataChange': function () { // 监听表格数据变化
     const tableFormTableData = this.tableForm.tableData
     let totalPurchaseAmount = 0
     tableFormTableData.forEach(item => {
       if (item.amount) {
         totalPurchaseAmount += Number(item.amount)
     }
     this.$set(this.contractForm, totalPurchaseAmount,Number(totalPurchaseAmount.toFixed(2)))
   })
}
methods:{
  用户输入触发事件：{
    this.tableFormTableDataChange +=1
  }
}
```

> 总结：
> 1.使用 watch 来实时监听属性变化
> 2.键值形式 键是data中的需要监听的数据 值是一个回调函数
> 3.键发生变化时，就调用回调函数
>
> 4.监听对象的内部属性变化时需要加上 `deep:true`深度监听

#### Vue.js this.$set的使用

1.如果data对象里面的数组、对象实例数据创建之后，其属性数值变化或者增添、删除属性,不会触发视图更新
2.属性必须在 data 对象上它才是响应的,不允许动态添加根级响应式属性。
3.this.$set和Vue.set原理几乎是一样的
4.this.$set的作用就是动态添加更新响应式属性
**使用方法**
this.$set(Array,"key",newValue)
this.$set(object, "propertyName", newValue)

#### Vuex[状态管理器](https://www.cnblogs.com/ff-upday/p/15507783.html)

#### VueJs(别名ref和$refs的使用)

1.ref相当于是给Dom元素起别名，这个是唯一的
2.可以通过$refs.别名来获取到整个Dom元素
3.子组件中的ref会注册到父组件的refs中，可以通过vm属性查看，父组键可以通过this.$refs.子组件的ref来访问子组件

#### vue中$forceUpdate()的使用

> 在vue中，数据的绑定都不用我们操心，例如在data中有一个msg的变量，修改它，那么在页面上，msg的内容就会自动发生变化。但是如果对于一个复杂的对象，例如一个对象数组，直接去给数组上某一个元素增加属性，或者直接把数组的length变成0，vue就无法知道发生了改变。

vue中尝试直接给某个item增加一个属性，发现页面上没有效果；直接将length变成0来清空数组，也没有效果，关键代码如下：

```jsx
change: function(index) {//增加性别属性
    this.list[index].sex = '男';
},
clear: function() {//清空数组
    this.list.length = 0;
}
```

> 其实呢，上面的写法没有效果，是因为没有按照vue的规范去写，因为vue文档里面写了，对于深层的，最好用$set方法，这样vue就可以知道发生了变化，同时vue也不建议直接修改length，可以给一个空数组来置空。

上面是按照vue的规范去写的，是可以实现变化的，关键代码如下：

```php
change: function(index) {//增加性别属性
    this.$set(this.list[index],'sex','男')
},
clear: function() {//清空数组
    this.list=[];
}
```

> 可是如果不想利用$set去设置，非要按照我们第一种方式去写，可以实现么？答案是可以的，就是利用$forceUpdate了，因为你修改了数据，但是页面层没有变动，说明数据本身是被修改了，但是vue没有监听到而已，用$forceUpdate就相当于按照最新数据给渲染一下。

关键代码如下：

```jsx
change: function(index) {
    this.list[index].sex = '男';
    this.$forceUpdate();
},
clear: function() {
    this.list.length = 0;
    this.$forceUpdate();
}
```

#### [Vue.js中this.$nextTick()的使用](https://www.cnblogs.com/jin-zhe/p/9985436.html)

this.$nextTick()将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。

#### v-html的使用

``` 
<span v-else-if="scope.column.property === 'purchaseContractType'" v-html="$options.filters.formatPurchaseContractType(scope.row.purchaseContractType)"></span>
```

#### filters过滤器的使用 [官方介绍](https://cn.vuejs.org/v2/guide/filters.html)

```
<span v-else-if="scope.column.property === 'purchaseContractType'" v-html="$options.filters.formatPurchaseContractType(scope.row.purchaseContractType)"></span>
```

```
filters: {
      // 给采购合同类型加颜色区分
      formatPurchaseContractType(type) {
        switch (String(type)) {
          case '现货采购':
            return `<span class="cell-badge cell-badge-yellow">${type}</span>`
          case '期货采购':
            return `<span class="cell-badge cell-badge-cyan">${type}</span>`
          case '以销定采':
            return `<span class="cell-badge cell-badge-blue">${type}</span>`
          default:
            return `<span class="cell-badge">${type}</span>`
        }
      },
      // 给是否预付款加颜色区分
      formatPurchasePrepaidStatus(state) {
        if (parseInt(state)) {
          return `<span class="cell-badge cell-badge-green">是</span>`
        } else {
          return `<span class="cell-badge cell-badge-gray">否</span>`
        }
      },
      // 给是否手动完成加颜色区分
      formatManualCompleteStatus(status) {
        if (Number(status) === 1) {
          return `<span class="cell-badge cell-badge-green">是</span>`
        } else {
          return `<span class="cell-badge cell-badge-gray">否</span>`
        }
      }
    },
```

#### mixin[混入](https://cn.vuejs.org/v2/guide/mixins.html)

#### [自定义指令](https://cn.vuejs.org/v2/guide/custom-directive.html)

#### vue中三级或三级路由不能缓存

解决三级路由缓存

```
router.beforeEach((to, from, next) => {
  // 解决keep-alive不能缓存三级菜单
  if (to.matched && to.matched.length > 2) {
    to.matched.splice(1,1)
  }
}
```

后续：加上这个后，三级页面组件复用，结果不执行[beforeRouteUpdate](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB) 这个方法

- 路由模式是 history，看了下代码，不是，默认是hash模式 排除
- 传参方式 `invoiceinit-edit/:id`没错





### js

#### [js遍历树，递归方法优化多层嵌套for循环](https://www.cnblogs.com/ff-upday/p/15374731.html)

#### 浅拷贝和深拷贝

> 主要是针对数组和对象
> 普通的赋值操作对于数组和对象来说，就只是把数据存贮的地址赋值给了变量

[![img](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108111140483-1493067127.png)](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108111140483-1493067127.png)

> 通过赋值操作，obj1和obj2都指向同一个地址 addr1,所以修改obj1或者obj2都会直接修改addr1下的数据，这样的赋值操作为浅拷贝

> 我们想要两个对象数值修改不相互影响，就要重新开辟一个存储位置并指向它，这样修改obj1或obj2数值都不会相互影响

#### 深拷贝方法：

##### 简单数组对象的拷贝方法

- 解构语法

```
//解构语法  针对于数组
let arr1 = [1,2,3,4,5]
let arr2 = [...arr1]
arr2[0] = 9999
console.log(arr1)
console.log(arr2)
//解构语法 针对于对象
let obj1 = {data:1000,name:'小象',sex:'女'}
let obj2 = {...obj1}
obj2.sex='男'
console.log(obj2)
console.log(obj1)
```

[![img](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108142007566-77747138.png)](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108142007566-77747138.png)

- JSON.parse(JSON.stringify()) 序列化和反序列

```
//序列化和反序列化
let obj1 = {data:80000,name:"davia",sex:"女"}
let obj2 = JSON.parse(JSON.stringify(obj1))
obj2.name='小红'
console.log(obj2)
console.log(obj1)
```

[![img](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108141016536-62177364.png)](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108141016536-62177364.png)

- 利用对象的API,Object.assign()进行深拷贝 Object.assign()方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。

```
let obj1 = {data:80000,name:"davia",sex:"女"}
let obj2={}
Object.assign(obj2,obj1)
obj2.name='小红'
console.log(obj2)
console.log(obj1)
```

[![img](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108140537573-1611966895.png)](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108140537573-1611966895.png)

- 利用 for in 循环

```
//数组
let arr=[1,2,3,4];
let arrClone=[];
for(let item in arr){
arrClone[item]=arr[item];
}
arrClone.push(5);
console.log(arrClone);
console.log(arr);

//对象
let obj={name:"小白",age:"15"};
let objClone={}
for(let item in obj){
objClone[item]=obj[item];
}
objClone.name="小红";
console.log(objClone);
console.log(obj);
```

[![img](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108142348382-1380154390.png)](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108142348382-1380154390.png)
[![img](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108142617689-1203382899.png)](https://img2020.cnblogs.com/blog/2062129/202111/2062129-20211108142617689-1203382899.png)

##### 对于有对象有数组的对象的深拷贝

- JSON.parse(JSON.stringify()) 序列化和反序列 可以把嵌套的数组对象一样深拷贝出来
- 递归方法

```
function deepClone(obj){
let objClone=obj instanceof Array?[]:{};
  for(let item in obj){
    let temp=obj[item] instanceof Object?deepClone(obj[item]):obj[item];
    objClone[item]=obj[item];
  }
  return objClone;
}
  let test={name:'小吧',age:'18'}
  let clone=deepClone(test);
  let arr1 = [8,60,50]
  let cloneArr1 = deepClone(arr1)
  cloneArr1[0] = 9000
  console.log(cloneArr1)
  console.log(arr1)
  clone.name="小八"
  console.log(clone);
  console.log(test);
```

#### js取绝对值
```
Math.abs()
```

#### 布尔值为false的六种情况

```
- undefined
- null
- false
- 0
- NaN
- ''空字符串，中间不能有空格
```

- 如果等号两边有Number类型，那另一个数据类型先转换为String类型，再装换为Number类型
- 注意空对象空数组的布尔值也为true
- []==true 为false，首先两边进行数据转换，[]->空String->0 true->1

##### 运算符的优先级

- 如果存在加号和三目运算符，记住加号优先于三目运算符

##### 强制转换

> Number() //强制转换成数值类型
> toString() //强制转换成字符串类型
> parseInt() //强制转换成数值类型

##### 隐式转换

转换为number类型：

算数运算符

> ```
> + - * / ++ --
> ```

比较运算符

> ```
> - > < >= <= == !==
> ```

> 比较运算符会把其它数据类型转换number数据类型后再比较
> 注意如果两边是字符串，会装换成对应的unicode编码来进行比较
> true-->1
> false-->0
> 有一个特殊的比较符===会判断数据类型，不会进行数据类型转换
> 转换为string类型

> `+`不仅是算数运算符，还可以作为字符串连接符把数据转换成stri当 + 号两边有一边是字符串，那这个+就是字符串连接符，会把其它数据类型调用toStirng()方法转成字符串然后拼接
> 作为算数运算符：会调用Number()转换为数字
> undefined会转换为NaN
> null会转换成数字0
> 转为boolean类型

> `!`
> **逻辑非运算符**
> 复杂数据类型转换的隐式转换
> 先调用valueOf()方法获取原始值，如果原始值不是number数据类型，则使用toString()方法转换成string类型

> **逻辑非隐式转换**
> 0 -0 NaN undefined null ""(空字符串)这几种情况转换布尔类型会得到false，除了这六种情况，其它所有数据类型都会得到true
> 运算符的各种优先级
> 算数运算符 >比较运算符>逻辑运算符>赋值运算符

#### 去除首位的空格的方式

##### [正则式](https://www.cnblogs.com/ff-upday/p/15513847.html)

##### 字符串原型方法

 `String.prototype.trm()`

#### 保留两位小数，最后一位小数为0，则保留一位小数

`Number(settlementAmount.toFixed(2))`

#### getBoundingClientRect函数 [介绍使用](https://www.cnblogs.com/shuiche/p/13863435.html)

#### Object.assign() [MDN介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

#### js添加和移除css样式

```
<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>信息管理</title>
	<!--通知ie使用最新内核-->
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<!--响应式，约束缩放-->
	<meta name="viewport" content="width=device-width, maxinum-scale=1,user-scalable=no,initial-scale=1">
	<link rel="stylesheet" href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css">  
	<script src="https://cdn.bootcss.com/jquery/2.1.1/jquery.min.js"></script>
	<script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	<style>
	    body{ background:#eee;}
	    #main{ max-width:640px; font-family:"微软雅黑"; }
	
	    /*头部*/
	    .tou{ background:#fff; margin-top:20px; padding-top:13px; padding-bottom:13px;}
	
	    /*头部左边*/
	    .tou .tou-left{ margin-left:15px;}
	    .tou .tou-left a{}
	    .tou .tou-left img{ width:78px; height:78px;}
	
	    /*头部右边*/
	    .tou .tou-right{ position:relative; float:left; margin-left:20px;}
	    .tou .tou-right h3{ font-size:18px; margin-top:3px; margin-bottom:8px;}
	    .tou .tou-right p{ font-size:14px; color:#999; margin-bottom:5px;}
	    .tou .tou-right .self-depart{ margin-bottom:0px;}
	
	    /*采集和已采集连接*/
	    .self-nav{ margin-top:20px; background:#fff; ;}
	    .self-nav .col-xs-6{ padding-left:0; padding-right:0; margin-left:0; margin-right:0; }
	    .self-nav .btn{ padding-top:10px; padding-bottom:10px;}
	
	    /*采集列表*/
	    .self-menu{ margin-top:20px; background:#fff;border-top:1px solid #fff; border-bottom:1px solid #fff; }
	    .self-menu .self-menu-cont li{ border-bottom:1px solid #eee;}
	    .self-menu .self-menu-cont li .self-danger{ background:#C00;}
	
	    /*底部技术支持*/
	    .self-footer{ margin-top:20px; background:#fff; padding-top:13px; padding-bottom:13px; }
	    .self-footer p{ margin-bottom:0; font-size:12px; color:#666; text-align:center;}
	</style>
</head>
<body>
	<div class=" container" id="main">
    	<!--头部-->
    	<div class="row tou">
        	<div class=" pull-left tou-left">
            	<a href="./"><img src="" class="img-responsive"/></a>
            </div>
            <div class=" tou-right">
            	<h3>张三</h3>
                <p>微信号：zhangsan</p>
                <p class="self-depart">部门：安全部</p>
            </div>
        </div>
        <!--banner-->
        <div class="row self-nav">
        	<div class="col-xs-6">
            <a href="#tab1" class="btn btn-block btn-default" data-toggle="tab" id="send" onclick="hiddenTag()">信息列表</a>
          </div>
          <div class="col-xs-6">
              <a href="#tab2" class="btn btn-block btn-default" data-toggle="tab" onclick="showTag()">添加信息</a>
          </div>
        </div>
        <!--菜单列表-->
        <div class="row self-menu">
        	<ul class="nav nav-pills nav-stacked self-menu-cont tab-pane active fade in" id="tab1">
              <li><a href="">信息列表<span class="badge pull-right">10</span></a></li>
              <li><a href="">消息列表<span class="badge pull-right">10</span></a></li>
              <li><a href="">留言列表<span class="badge pull-right">10</span></a></li>
              <li><a href="">传达列表<span class="badge pull-right">10</span></a></li>
              <li><a href="">通知列表<span class="badge pull-right">10</span></a></li>
          </ul>
          <ul class="nav nav-pills nav-stacked self-menu-cont tab-pane fade" id="tab2" style="display:none">
              <li><a href="">添加信息</a></li>
              <li><a href="">添加消息</a></li>
              <li><a href="">添加留言</a></li>
              <li><a href="">添加传达</a></li>
              <li><a href="">添加通知</a></li>
          </ul>
        </div>
     </div>   
</body>
<script>
    function hiddenTag(){
      //通过JS添加样式+移除样式
      document.getElementById('tab1').style.display="block";
      document.getElementById('tab2').style.display="none";

      //通过jQuery添加类选择器和移除类选择器
      $("#add").removeClass("btn-primary");
      $("#add").addClass("btn-default");
      $("#send").removeClass("btn-default");
      $("#send").addClass("btn-primary");

      //通过jQuery添加样式+移除样式
      // $('#tab1').css("display","block");
      // $('#tab2').css("display","none");
    }
    function showTag(){
      //通过JS添加样式+移除样式
      document.getElementById('tab1').style.display="none";
      document.getElementById("tab2").removeAttribute("style");

      //通过jQuery添加类选择器和移除类选择器
      $("#send").removeClass("btn-primary");
      $("#send").addClass("btn-default");
      $("#add").removeClass("btn-default");
      $("#add").addClass("btn-primary");
      
      //通过jQuery添加样式+移除样式
      // $("#tab1").css("display","none");
      // $("#tab2").removeAttr("style","");
    }
</script>
</html>
```

把对象当成一个数组，对象支持使用类似于下标形式的方法来把属性和属性值赋给对象，但是对象依然是对象，obj.length是不存在

```
let arr = ['cpmc','cpsl']
			let obj = [{cpmc:'名称',cpsl:'1'}]
			arr.forEach((item,index)=>{
				obj.forEach((item2,index2)=>{
					// console.log(item)
					console.log(item2[item])
				})
			})
```

#### js获取网页高度

```
Js获取高度：

网页可见区域高：document.body.clientHeight 

网页可见区域高：document.body.offsetHeight (包括边线的宽) 

网页正文全文高：document.body.scrollHeight 
网页被卷去的高：document.body.scrollTop 

屏幕分辨率的高：window.screen.height 

屏幕可用工作区高度：window.screen.availHeight 
```

#### 关于js浮点数计算精度不准确问题

> 首先，我们要站在计算机的角度思考 0.1 + 0.2 这个看似小儿科的问题。我们知道，能被计算机读懂的是二进制，而不是十进制，所以我们先把 0.1 和 0.2 转换成二进制看看：
>
> 0.1 => 0.0001 1001 1001 1001…（无限循环）
> 0.2 => 0.0011 0011 0011 0011…（无限循环）
>
> 上面我们发现0.1和0.2转化为二进制之后，变成了一个无限循环的数字，这在现实生活中，无限循环我们可以理解，但计算机是不允许无限循环的，对于无限循环的小数，计算机会进行舍入处理。进行双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。
>
> 知道了浮点数产生的原因了，那么怎么处理这个问题呢？

方法一：指定要保留的小数位数(0.1+0.2).toFixed(1) = 0.3;这个方法toFixed是进行四舍五入的也不是很精准，对于计算金额这种严谨的问题，不推荐使用，而且不通浏览器对toFixed的计算结果也存在差异。

toFixed()的实质是银行家舍入发  **四舍六入五成双** (谷歌浏览器又不太遵守这个规则，结果有些还是不对)

解释：

> （1）被修约的数字小于5时，该数字舍去；
>
> （2）被修约的数字大于5时，则进位；
>
> （3）被修约的数字等于5时，要看5前面的数字，若是奇数则进位，若是偶数则将5舍掉，即修约后末尾数字都成为偶数；若5的后面还有不为“0”的任何数，则此时无论5的前面是奇数还是偶数，均应进位。



方法二：把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。 

```
Math.round()方法用来把一个数字舍入为最接近的整数，其舍去的方法是四舍五入方法，符合我们四舍五入的需求。
使用：
Math.round(x * 100) / 100;
```

![image-20220113141225899](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220113141225899.png)

如果被舍的数字是5结果不会进行舍入，有精度问题

加上Number.EPSILON

```
console.log(Math.round(1.225*1*100+Number.EPSILON)/100)
```

![image-20220113141738527](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220113141738527.png)

还是不行

网上参考方法  （数字太大就不行）

```
Number.prototype.toFixed=function (d) { 
  return parseInt(this * Math.pow(10, d) + 0.5) / Math.pow(10,  d);
};
```

使用工具mathJs

#### [mathJs](https://www.mathjs.cn/examples/expressions.js.html)

[借鉴文章1](https://blog.csdn.net/qq_36321909/article/details/107326742)

```
Math.js 是一个用于JavaScript和Node.js的扩展数学库。它具有支持符号计算的灵活表达式解析器，大量内置函数和常量，并提供了集成的解决方案来处理不同的数据类型，例如数字，大数，复数，分数，单位和矩阵
```

配置config

注意要修改配置 必须

```
import { create, all } from 'mathjs';
const mathjs = create(all);
```

```
// 改变配置
math.config({
  number: 'BigNumber' //大数字类型
})
```

```
Math.js支持三种类型的数字：
number 快速浮点运算的编号
BigNumber用于任意精度算术，在大数字页上进行了 介绍。
fraction分数，以分子和分母的形式存储数字
```

舍入误差

```
在大多数情况下，舍入误差并不重要：它们对结果没有重大影响。但是，在向用户显示输出时，它看起来很难看。一种解决方案是将精度限制在显示的输出中，使其恰好低于实际的16位数字精度
```

```
import { create, all } from 'mathjs';
const mathjs = create(all);

function printFn(value,precision=12) {
  return Number(mathjs.format(value, precision))
}

console.log(18.711*4745)
console.log(mathjs.round(printFn(18.711*4745,8),2))
console.log(0.1+0.2)
console.log(mathjs.round(printFn(0.1+0.2,16),2))
console.log(mathjs.round(printFn(1.1*100,64),2))
console.log(0.3-0.1)
console.log(mathjs.round(printFn(0.3-0.1,8),2))
console.log(printFn(0.1 + 0.2))
console.log(printFn(1.1 * 100))
console.log(mathjs.round(printFn(18.711*4745),2))
console.log(mathjs.multiply(1.1,100))
```

> 这样还是沿用内部的浮点计算，只是把精度降低了，

#### [number-precision](https://github.com/nefe/number-precision)

[借鉴文章](https://github.com/camsong/blog/issues/9)

#### bigjs

[借鉴文章](https://juejin.cn/post/6900567809038745608)



### elementUI

#### [elementUI table固定列渲染错位](https://www.cnblogs.com/ff-upday/p/15568140.html)

可在数据更新的时候，执行重绘

```
updated() {
      this.$nextTick(() => { this.$refs.multipleTable.doLayout()});
    },
```

![image-20220113153332056](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220113153332056.png)

发现一个特殊值

#### table表头数据循环key值重复导致页面卡顿

场景：

页面明细单据按钮切换重新请求列数据，页面出现卡顿，渲染慢

错误代码

```
<el-table-column v-for="(item, index) in col" :key="item.index" :prop="item.prop"
:label="item.nowLabel" v-if="!item.hidden" :width="item.nowWidth" :type="item.type" :fixed="item.fixed" :show-overflow-tooltip="item.showOverflowTooltip" :align="item.nowAlign">
            <template slot-scope="scope">
          </el-table-column>
        </el-table>
```

原因：当watch监听到按钮切换，去请求列数据重新渲染，由于key值都是绑定的索引值 ：`:key="item.index"`

key值没有变，vue会复用之前的组件，但是vue又监听到请求的数据有变化，需要重新渲染

```
watch:{
      listType: function() {
        //单据明细切换时重新请求表头属性
        this.Get_purchaseColProps()
      }
    },
```

```
<el-table-column v-for="(item, index) in col" :key="item.id" :prop="item.prop"
:label="item.nowLabel" v-if="!item.hidden" :width="item.nowWidth" :type="item.type" :fixed="item.fixed" :show-overflow-tooltip="item.showOverflowTooltip" :align="item.nowAlign">
            <template slot-scope="scope">
          </el-table-column>
        </el-table>
```

#### table组件实现列拖拽

使用[sortable.js](https://www.itxst.com/sortablejs/neuinffi.html)插件

```
npm install sortablejs --save


```

> 必须给循环的数据绑定key值，唯一的

```
<el-table-column v-for="(item, index) in col" :key="item.index" :prop="item.prop"
:label="item.nowLabel" v-if="!item.hidden" :width="item.nowWidth" :type="item.type" :fixed="item.fixed" :show-overflow-tooltip="item.showOverflowTooltip" :align="item.nowAlign">
            <template slot-scope="scope">
          </el-table-column>
        </el-table>
```

```
//列拖拽
      columnDrop() {
        const wrapperTr = document.querySelector('.el-table__header-wrapper tr')
        var ops ={
          animation: 180,
          delay: 0,
          onEnd: evt => {
            let oldIndex = evt.oldIndex
            let newIndex = evt.newIndex
            const oldItem = this.col[oldIndex]
            this.$set(this.col[oldIndex],'id',Math.random())
            this.$set(this.col[newIndex],'id',Math.random())
            this.col.splice(oldIndex, 1)
            this.col.splice(newIndex, 0, oldItem)
          },
        }
        this.$sortable.create(wrapperTr,ops)
      },
```

> 直接在mounted函数中调用

#### 列设置组件

抽屉组件和树形组件

```
//使用
<el-button @click="drawer = true" icon="el-icon-s-operation">列设置</el-button>

methods:{
//列设置重置
      handleReback() {
        this.Get_purchaseColProps()
      },
      //抽屉组件打开关闭
      changeDrawer(v){
        this.drawer = v;
      },
      // tree更新时拖动表格
      handleDrop() {
        this.tableKey++
      },
}
```

```
@@ -0,0 +1,128 @@
<template>
 <div>
   <el-drawer
   :visible.sync="drawer_"
   :with-header="false"
   size="20%"
   >
     <div class="custom-setting">
       <h3>配置列项</h3>
       <el-button type="text" @click="handleReback">重置</el-button>
     </div>
     <el-tree 
     :key="colKey" 
     draggable 
     :data="col" 
     :props="defaultProps" 
     :allow-drag="allowDrag" 
     :allow-drop="allowDrop" 
     @node-drop="handleDrop"
     >
       <span class="tree-table-setting" slot-scope="{node,data}" :class="{fixedActivated: data.fixed !== null}">
         <span>
           <el-switch v-model="data.hidden" :active-value="false" :inactive-value="true"></el-switch>
           <span>{{node.label}}</span>
         </span>
         <span>
           <el-tooltip
            effect="dark" content="左固定" placement="top-start">
              <i id="left" :class="{activatedFixed: data.fixed === 'left'}" @click="handleFixed(data,'left')" class="iconfont icon-zuo-guding"></i>
           </el-tooltip>
           <el-tooltip
            effect="dark" content="右固定" placement="top-start">
              <i id="right" :class="{activatedFixed: data.fixed === 'right'}" @click="handleFixed(data,'right')" class="iconfont icon-you-guding"></i>
           </el-tooltip>
           <el-tooltip
            effect="dark" content="取消固定" placement="top-start">
              <i id="noFixed" :class="{activatedFixed: data.fixed === null}"  @click="cancelFixed(data)" class="iconfont icon-quxiaoguding"></i>
           </el-tooltip>
         </span>
       </span>
     </el-tree>
   </el-drawer>
 </div>
</template>

<script>
 export default {
   name:'CustomSet' ,
   props:{
     col:{
       type:Array,
       default:[]
     },
     drawer:{
       type:Boolean,
       default:false
     }
   },
   data () {
     return {
       colKey:1,
       //列设置中tree配置
       defaultProps: {
         children: 'children',
         label: 'label'
       },
     }
   },
   computed: {
     drawer_: {
       get() {
         return this.drawer
       },
       set(v) {
         this.$emit('changeDrawer',v)
       }
     }
   },
   methods:{
     //重置
      handleReback() {
        this.$emit('handleReback')
      },
      //是否允许拖拽
      allowDrag(draggingNode) {
        return draggingNode.data.fixed === null
      },
      //仅允许tree节点上下拖动
      allowDrop(draggingNode,dropNode,type) {
        return type !== 'inner'
      },
      // tree更新时拖动表格
      handleDrop() {
        this.$emit('handleDrop')
      },
      //列固定
      handleFixed(CurrentColumn,direction) {
        this.$emit('handleFixed',CurrentColumn,direction)
      },
      //取消固定
      cancelFixed(CurrentColumn) {
        this.$emit('cancelFixed',CurrentColumn)
      },
   }
 }
</script>

<style type="text/scss" lang="scss" scoped>
//列设置
 .tree-table-setting {
   flex: 1;
   display: flex;
   align-items: center;
   justify-content: space-between;
   font-size: 14px;
   padding-right: 8px;
 }
 //列头设置
 .custom-setting {
   padding: 5px 20px;
   margin-bottom: 10px;
   background-color: #f3f3f3;
   display: flex;
   justify-content: space-between;
   align-items: center;
 }
 .activatedFixed {
   color: #409eff;
 }
 .fixedActivated {
   color: #ccc;
 }
</style>
```



#### table组件右击表头自定义菜单

```
//列固定
      handleFixed(CurrentColumn,direction) {
        this.menuVisible = false
        this.col.forEach((item,index) => {
          if(item.label === CurrentColumn.label) {
            this.$set(this.col[index],'fixed',direction)
            this.$set(this.col[index],'style',true)
          }
        })
      },
      //取消固定
      cancelFixed(CurrentColumn) {
        this.menuVisible = false
        this.col.forEach((item,index) => {
          if(item.label === CurrentColumn.label){
            this.$set(this.col[index],'fixed',null)
          }
        })
      },
      showContextmenu(column, event) {
        event.preventDefault() //关闭浏览器右键默认事件
        this.menuVisible = false // 先把模态框关死，目的是 第二次或者第n次右键鼠标的时候 它默认的是true
        this.menuVisible = true // 显示模态窗口，跳出自定义菜单栏
        this.CurrentColumn = column
        var menu = document.querySelector('.menu')
        this.styleMenu(menu)
      },
      foo() {
        // 取消鼠标监听事件 菜单栏
        this.menuVisible = false
        document.removeEventListener('click', this.foo) // 关掉监听，
      },
      styleMenu(menu) {
        menu.style.left = event.x - 150 + 'px'
        document.addEventListener('click', this.foo) // 给整个document新增监听鼠标事件，点击任何位置执行foo方法
        menu.style.top = event.y - 215 + 'px'
      },
```

#### 在axios网络请求的拦截器中配置全局加载状态和按钮加载状态

[Axios](https://www.axios-http.cn/) 是基于 promise 的网络请求库

注意按钮saveLoading是放到了vuex状态管理器里面

```
// 创建axios实例
const service = axios.create({
  baseURL: '/api/',
  timeout: 30000,
  httpsAgent: new https.Agent({
    rejectUnauthorized: false
  }),
  paramsSerializer: params => qs.stringify(params, { arrayFormat: 'repeat' })
})
```

```
// request拦截器
service.interceptors.request.use(config => {
  // 如果是put/post请求，用qs.stringify序列化参数
  const is_put_post = config.method === 'put' || config.method === 'post'
  const is_json = config.headers['Content-Type'] === 'application/json'
  if (is_put_post && is_json) {
    config.data = JSON.stringify(config.data)
  }
  if (is_put_post && !is_json) {
    config.data = qs.stringify(config.data, { arrayFormat: 'repeat' })
  }
  // Do something before request is sent
  /** 配置全屏加载 */
  if (config.loading !== false) {
    config.loading = Loading.service({
      lock: true,
      background: 'rgba(0, 0, 0, 0.7)',
      spinner: 'el-icon-loading',
      text: '请稍候...'
    })
  }

  /** 保存按钮loading */
  if (config.saveLoading === true) {
    if (store.getters.saveLoading) return
    console.log(111)
    store.dispatch('setSaveLoading', true)
  }

  // uuid
  const uuid = Storage.getItem('materials_uuid')
  config.headers['uuid'] = uuid

  /** 设置令牌 */
  let accessToken = Storage.getItem('materials_access_token')
  if (accessToken) {
    config.headers['Authorization'] = accessToken
  }
  /** 设置账套令牌 */
  let tenantId = Storage.getItem('tenantId')
  if (tenantId) {
    config.headers['tenantId'] = tenantId
  }
  return config
}, error => {
  Promise.reject(error)
})
```

```
// respone拦截器
service.interceptors.response.use(
  async response => {
    await closeLoading(response)
    store.dispatch('setSaveLoading', false)
    return response.data
  },
  async error => {
    await closeLoading(error)
    store.dispatch('setSaveLoading', false)
    const error_response = error.response || {}
    const error_data = error_response.data || {}
    if (error.config.message !== false) {
      let _message = error.code === 'ECONNABORTED' ? '连接超时，请稍候再试！' : '网络错误，请稍后再试！'
      Vue.prototype.$message.error(error_data.msg || error_data.message || _message)
    }
    return Promise.reject(error)
  }
)

/**
 * 关闭全局加载
 * 延迟200毫秒关闭，以免晃眼睛
 * @param target
 */
const closeLoading = (target) => {
  if (!target.config.loading) return true
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      target.config.loading.close()
      resolve()
    }, 200)
  })
}
```

tagsView标签栏组件封装

主要使用的vuex状态管理器

#### slot-scope [作用域插槽](https://cloud.tencent.com/developer/article/1601536#:~:text=slot-sco,就是作用域插槽。)



### uniapp

#### uni中的事件

##### 事件绑定

在uni中事件绑定和vue中是一样的，通过v-on进行事件的绑定，也可以简写为@

```html
<button @click="tapHandle">点我啊</button>
```

事件函数定义在methods中

```js
methods: {
  tapHandle () {
    console.log('真的点我了')
  }
}
```

##### 事件传参

- 默认如果没有传递参数，事件函数第一个形参为事件对象

  ```
  // template
  <button @click="tapHandle">点我啊</button>
  // script
  methods: {
    tapHandle (e) {
      console.log(e)
    }
  }
  ```

- 如果给事件函数传递参数了，则对应的事件函数形参接收的则是传递过来的数据

  ```
  // template
  <button @click="tapHandle(1)">点我啊</button>
  // script
  methods: {
    tapHandle (num) {
      console.log(num)
    }
  }
  ```

- 如果获取事件对象也想传递参数

  ```
  // template
  <button @click="tapHandle(1,$event)">点我啊</button>
  // script
  methods: {
    tapHandle (num,e) {
      console.log(num,e)
    }
  }
  ```

#### uni的生命周期

##### 应用的生命周期

生命周期的概念：一个对象从创建、运行、销毁的整个过程被成为生命周期。

生命周期函数：在生命周期中每个阶段会伴随着每一个函数的触发，这些函数被称为生命周期函数

`uni-app` 支持如下应用生命周期函数：

| 函数名   | 说明                                           |
| -------- | ---------------------------------------------- |
| onLaunch | 当`uni-app` 初始化完成时触发（全局只触发一次） |
| onShow   | 当 `uni-app` 启动，或从后台进入前台显示        |
| onHide   | 当 `uni-app` 从前台进入后台                    |
| onError  | 当 `uni-app` 报错时触发                        |

##### 页面的生命周期

`uni-app` 支持如下页面生命周期函数：

| 函数名   | 说明                                                         | 平台差异说明 | 最低版本 |
| -------- | ------------------------------------------------------------ | ------------ | -------- |
| onLoad   | 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参），参考[示例](https://uniapp.dcloud.io/api/router?id=navigateto) |              |          |
| onShow   | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |              |          |
| onReady  | 监听页面初次渲染完成。                                       |              |          |
| onHide   | 监听页面隐藏                                                 |              |          |
| onUnload | 监听页面卸载                                                 |              |          |

#### 下拉刷新

##### 开启下拉刷新

在uni-app中有两种方式开启下拉刷新

+ 需要在 `pages.json` 里，找到的当前页面的pages节点，并在 `style` 选项中开启 `enablePullDownRefresh`
+ 通过调用uni.startPullDownRefresh方法来开启下拉刷新


###### 通过配置文件开启

创建list页面进行演示

```html
<template>
	<view>
		杭州学科
		<view v-for="(item,index) in arr" :key="index">
			{{item}}
		</view>
	</view>
</template>

<script>
	export default {
		data () {
			return {
				arr: ['前端','java','ui','大数据']
			}
		}
	}
</script>

<style>
</style>
```

通过pages.json文件中找到当前页面的pages节点，并在 `style` 选项中开启 `enablePullDownRefresh`

```js
{
  "path":"pages/list/list",
    "style":{
      "enablePullDownRefresh": true
    }
}
```

###### 通过API开启

[api文档](https://uniapp.dcloud.io/api/ui/pulldown)

```html
uni.startPullDownRefresh()
```

##### 监听下拉刷新

通过onPullDownRefresh可以监听到下拉刷新的动作

```js
export default {
  data () {
    return {
      arr: ['前端','java','ui','大数据']
    }
  },
  methods: {
    startPull () {
      uni.startPullDownRefresh()
    }
  },
  onPullDownRefresh () {
    console.log('触发下拉刷新了')
  }
}
```

##### 关闭下拉刷新

uni.stopPullDownRefresh()

停止当前页面下拉刷新。

案例演示

```html
<template>
	<view>
		<button type="primary" @click="startPull">开启下拉刷新</button>
		杭州学科
		<view v-for="(item,index) in arr" :key="index">
			{{item}}
		</view>
	</view>
</template>
<script>
	export default {
		data () {
			return {
				arr: ['前端','java','ui','大数据']
			}
		},
		methods: {
			startPull () {
				uni.startPullDownRefresh()
			}
		},
		
		onPullDownRefresh () {
			this.arr = []
			setTimeout(()=> {
				this.arr = ['前端','java','ui','大数据']
				uni.stopPullDownRefresh()
			}, 1000);
		}
	}
</script>
```

#### 上拉加载

通过在pages.json文件中找到当前页面的pages节点下style中配置onReachBottomDistance可以设置距离底部开启加载的距离，默认为50px

通过onReachBottom监听到触底的行为

```js
<template>
	<view>
		<button type="primary" @click="startPull">开启下拉刷新</button>
		杭州学科
		<view v-for="(item,index) in arr" :key="index">
			{{item}}
		</view>
	</view>
</template>
<script>
	export default {
		data () {
			return {
				arr: ['前端','java','ui','大数据','前端','java','ui','大数据']
			}
		},
		onReachBottom () {
			console.log('触底了')
		}
	}
</script>

<style>
	view{
		height: 100px;
		line-height: 100px;
	}
</style>
```

#### 网络请求

在uni中可以调用uni.request方法进行请求网络请求

需要注意的是：在小程序中网络相关的 API 在使用前需要配置域名白名单。

**发送get请求**

```js
<template>
	<view>
		<button @click="sendGet">发送请求</button>
	</view>
</template>
<script>
	export default {
		methods: {
			sendGet () {
				uni.request({
					url: 'http://localhost:8082/api/getlunbo',
					success(res) {
						console.log(res)
					}
				})
			}
		}
	}
</script>
```

**发送post请求**

#### 数据缓存

##### **uni.setStorage**

[官方文档](https://uniapp.dcloud.io/api/storage/storage?id=setstorage)

将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。

代码演示

```js
<template>
	<view>
		<button type="primary" @click="setStor">存储数据</button>
	</view>
</template>

<script>
	export default {
		methods: {
			setStor () {
				uni.setStorage({
				 	key: 'id',
				 	data: 100,
				 	success () {
				 		console.log('存储成功')
				 	}
				 })
			}
		}
	}
</script>

<style>
</style>
```

##### uni.setStorageSync

将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个同步接口。

代码演示

```js
<template>
	<view>
		<button type="primary" @click="setStor">存储数据</button>
	</view>
</template>

<script>
	export default {
		methods: {
			setStor () {
				uni.setStorageSync('id',100)
			}
		}
	}
</script>

<style>
</style>
```

##### uni.getStorage

从本地缓存中异步获取指定 key 对应的内容。

代码演示

```html
<template>
	<view>
		<button type="primary" @click="getStorage">获取数据</button>
	</view>
</template>
<script>
	export default {
		data () {
			return {
				id: ''
			}
		},
		methods: {
			getStorage () {
				uni.getStorage({
					key: 'id',
					success:  res=>{
						this.id = res.data
					}
				})
			}
		}
	}
</script>
```

##### uni.getStorageSync

从本地缓存中同步获取指定 key 对应的内容。

代码演示

```html
<template>
	<view>
		<button type="primary" @click="getStorage">获取数据</button>
	</view>
</template>
<script>
	export default {
		methods: {
			getStorage () {
				const id = uni.getStorageSync('id')
				console.log(id)
			}
		}
	}
</script>
```

##### uni.removeStorage

从本地缓存中异步移除指定 key。

代码演示

```html
<template>
	<view>
		<button type="primary" @click="removeStorage">删除数据</button>
	</view>
</template>
<script>
	export default {
		methods: {
			removeStorage () {
				uni.removeStorage({
					key: 'id',
					success: function () {
						console.log('删除成功')
					}
				})
			}
		}
	}
</script>
```

##### uni.removeStorageSync

从本地缓存中同步移除指定 key。

代码演示

```html
<template>
	<view>
		<button type="primary" @click="removeStorage">删除数据</button>
	</view>
</template>
<script>
	export default {
		methods: {
			removeStorage () {
				uni.removeStorageSync('id')
			}
		}
	}
</script>
```

#### 上传图片、预览图片

##### 上传图片

uni.chooseImage方法从本地相册选择图片或使用相机拍照。

案例代码

```html
<template>
	<view>
		<button @click="chooseImg" type="primary">上传图片</button>
		<view>
			<image v-for="item in imgArr" :src="item" :key="index"></image>
		</view>
	</view>
</template>

<script>
	export default {
		data () {
			return {
				imgArr: []
			}
		},
		methods: {
			chooseImg () {
				uni.chooseImage({
					count: 9,
					success: res=>{
						this.imgArr = res.tempFilePaths
					}
				})
			}
		}
	}
</script>
```

##### 预览图片

结构

```html
<view>
	<image v-for="item in imgArr" :src="item" @click="previewImg(item)" :key="item"></image>
</view>
```

预览图片的方法

```js
previewImg (current) {
  uni.previewImage({
    urls: this.imgArr,
    current
  })
}
```

#### 条件注释实现跨段兼容

条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。

**写法：**以 #ifdef 加平台标识 开头，以 #endif 结尾。

平台标识

| 值         | 平台                                                   | 参考文档                                                     |
| ---------- | ------------------------------------------------------ | ------------------------------------------------------------ |
| APP-PLUS   | 5+App                                                  | [HTML5+ 规范](http://www.html5plus.org/doc/)                 |
| H5         | H5                                                     |                                                              |
| MP-WEIXIN  | 微信小程序                                             | [微信小程序](https://developers.weixin.qq.com/miniprogram/dev/api/) |
| MP-ALIPAY  | 支付宝小程序                                           | [支付宝小程序](https://docs.alipay.com/mini/developer/getting-started) |
| MP-BAIDU   | 百度小程序                                             | [百度小程序](https://smartprogram.baidu.com/docs/develop/tutorial/codedir/) |
| MP-TOUTIAO | 头条小程序                                             | [头条小程序](https://developer.toutiao.com/dev/cn/mini-app/develop/framework/basic-reference/introduction) |
| MP-QQ      | QQ小程序                                               | （目前仅cli版支持）                                          |
| MP         | 微信小程序/支付宝小程序/百度小程序/头条小程序/QQ小程序 |                                                              |

##### 组件的条件注释

代码演示

```html
<!-- #ifdef H5 -->
<view>
  h5页面会显示
</view>
<!-- #endif -->
<!-- #ifdef MP-WEIXIN -->
<view>
  微信小程序会显示
</view>
<!-- #endif -->
<!-- #ifdef APP-PLUS -->
<view>
  app会显示
</view>
<!-- #endif -->
```

##### api的条件注释

代码演示

```js
onLoad () {
  //#ifdef MP-WEIXIN
  console.log('微信小程序')
  //#endif
  //#ifdef H5
  console.log('h5页面')
  //#endif
}
```

样式的条件注释

代码演示

```css
/* #ifdef H5 */
view{
  height: 100px;
  line-height: 100px;
  background: red;
}
/* #endif */
/* #ifdef MP-WEIXIN */
view{
  height: 100px;
  line-height: 100px;
  background: green;
}
/* #endif */
```

#### uni中的导航跳转

##### 利用navigator进行跳转

navigator详细文档：[文档地址](https://uniapp.dcloud.io/component/navigator)

跳转到普通页面

```html
<navigator url="/pages/about/about" hover-class="navigator-hover">
  <button type="default">跳转到关于页面</button>
</navigator>
```

跳转到tabbar页面

```html
<navigator url="/pages/message/message" open-type="switchTab">
  <button type="default">跳转到message页面</button>
</navigator>
```

##### 利用编程式导航进行跳转

[导航跳转文档]( [uni.navigateTo](https://uniapp.dcloud.io/api/router?id=navigateto))

**利用navigateTo进行导航跳转**

保留当前页面，跳转到应用内的某个页面，使用`uni.navigateBack`可以返回到原页面。

```html
<button type="primary" @click="goAbout">跳转到关于页面</button>
```

通过navigateTo方法进行跳转到普通页面

```js
goAbout () {
  uni.navigateTo({
    url: '/pages/about/about',
  })
}
```

**通过switchTab跳转到tabbar页面**

跳转到tabbar页面

```html
<button type="primary" @click="goMessage">跳转到message页面</button>
```

通过switchTab方法进行跳转

```js
goMessage () {
  uni.switchTab({
    url: '/pages/message/message'
  })
}
```

**redirectTo进行跳转** 

关闭当前页面，跳转到应用内的某个页面。

```html
<!-- template -->
<button type="primary" @click="goMessage">跳转到message页面</button>
<!-- js -->
goMessage () {
  uni.switchTab({
    url: '/pages/message/message'
  })
}
```

通过onUnload测试当前组件确实卸载

```js
onUnload () {
  console.log('组件卸载了')
}
```

##### 导航跳转传递参数

在导航进行跳转到下一个页面的同时，可以给下一个页面传递相应的参数，接收参数的页面可以通过onLoad生命周期进行接收

传递参数的页面

```js
goAbout () {
  uni.navigateTo({
    url: '/pages/about/about?id=80',
  });
}
```

接收参数的页面

```js
<script>
	export default {
		onLoad (options) {
			console.log(options)
		}
	}
</script>
```

传递多个参数

```

uni.navigateTo({
    url: '/pages/about/about?id=80'+'&ProductID='+this.ProductID,
  });
```



#### uni-app中组件的创建

在uni-app中，可以通过创建一个后缀名为vue的文件，即创建一个组件成功，其他组件可以将该组件通过impot的方式导入，在通过components进行注册即可

+ 创建login组件，在component中创建login目录，然后新建login.vue文件

  ```
  <template>
  	<view>
  		这是一个自定义组件
  	</view>
  </template>
  
  <script>
  </script>
  
  <style>
  </style>
  ```

+ 在其他组件中导入该组件并注册

  ```
  import login from "@/components/test/test.vue"
  ```

+ 注册组件

  ```js
  components: {test}
  ```

+ 使用组件

  ```
  <test></test>
  ```


##### 组件的生命周期函数

| beforeCreate  | 在实例初始化之后被调用。[详见](https://cn.vuejs.org/v2/api/#beforeCreate) |              |      |
| ------------- | ------------------------------------------------------------ | ------------ | ---- |
| created       | 在实例创建完成后被立即调用。[详见](https://cn.vuejs.org/v2/api/#created) |              |      |
| beforeMount   | 在挂载开始之前被调用。[详见](https://cn.vuejs.org/v2/api/#beforeMount) |              |      |
| mounted       | 挂载到实例上去之后调用。[详见](https://cn.vuejs.org/v2/api/#mounted) 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用`$nextTick`[Vue官方文档](https://cn.vuejs.org/v2/api/#Vue-nextTick) |              |      |
| beforeUpdate  | 数据更新时调用，发生在虚拟 DOM 打补丁之前。[详见](https://cn.vuejs.org/v2/api/#beforeUpdate) | 仅H5平台支持 |      |
| updated       | 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。[详见](https://cn.vuejs.org/v2/api/#updated) | 仅H5平台支持 |      |
| beforeDestroy | 实例销毁之前调用。在这一步，实例仍然完全可用。[详见](https://cn.vuejs.org/v2/api/#beforeDestroy) |              |      |
| destroyed     | Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。[详见](https://cn.vuejs.org/v2/api/#destroyed) |              |      |

#### 组件的通讯

##### 父组件给子组件传值

通过props来接受外界传递到组件内部的值

```
<template>
	<view>
		这是一个自定义组件 {{msg}}
	</view>
</template>

<script>
	export default {
		props: ['msg']
	}
</script>

<style>
</style>
```

其他组件在使用login组件的时候传递值

```
<template>
	<view>
		<test :msg="msg"></test>
	</view>
</template>

<script>
	import test from "@/components/test/test.vue"
	export default {
		data () {
			return {
				msg: 'hello'
			}
		},
		
		components: {test}
	}
</script>
```

##### 子组件给父组件传值

通过$emit触发事件进行传递参数

```html
<template>
	<view>
		这是一个自定义组件 {{msg}}
		<button type="primary" @click="sendMsg">给父组件传值</button>
	</view>
</template>

<script>
	export default {
		data () {
			return {
				status: '打篮球'
			}
		},
		props: {
			msg: {
				type: String,
				value: ''
			}
		},
		methods: {
			sendMsg () {
				this.$emit('myEvent',this.status)
			}
		}
	}
</script>
```

父组件定义自定义事件并接收参数

```html
<template>
	<view>
		<test :msg="msg" @myEvent="getMsg"></test>
	</view>
</template>
<script>
	import test from "@/components/test/test.vue"
	export default {
		data () {
			return {
				msg: 'hello'
			}
		},
		methods: {
			getMsg (res) {
				console.log(res)
			}
		},
		
		components: {test}
	}
</script>
```



#### 过关斩将

##### 1、如何使用uni.$emit()和uni.$on() 进行页面间通讯

[参考地址](https://uniapp.dcloud.io/collocation/frame/communication?id=emit)

##### 2、页面设置导航栏的标题

```\
//标题
uni.setNavigationBarTitle({
  title: '标题'
});
```

##### 3、导航栏添加按钮图标

在页面配置中 pages.json 

```
"app-plus": {
				"titleNView": {
					"buttons": [{
						"text": "\ue67a",
						"fontSize": "28px",
						"fontSrc": "/static/iconfont.ttf"
					}]
				},
				"softinputMode": "adjustResize"
			}
```

监听按钮  `onNavigationBarButtonTap`

```
			onNavigationBarButtonTap() {
				uni.navigateTo({
				  url: '/pages/work/OnlineOrder/OnlineOrderAdd'
				});
			}
```

##### 4、 js格式化日期 momentjs的基本使用 [官方地址](http://momentjs.cn/)

- 直接在官方复制momentJs多语言支持的代码
- 在本地项目工具类文件夹（与pages同级）新建一个moment.js文件粘贴
- 在main.js中引入
- 在vue原型中注册 `Vue.prototype.$moment = moment`
- 这样全局可以使用this.$moment

> 关于Vue.prototype [参考文章](https://www.qiyuandi.com/zhanzhang/zonghe/17046.html)

##### 6、如何使用js绑定事件

```
document.getElementById("btn1").onclick = function () {
        console.log("码仙");
    };
```

##### 7、uni-app页面间通信可用于全局监听事件，跨页面传递数据

[参考文章](https://uniapp.dcloud.io/collocation/frame/communication?id=off)

$on和$once区别

$on，不管什么时候触发，都会监听

$once配和$off取消监听使用，只监听一次

```
/* 添加明细 */
		handleAdd() {
			let _this = this
			/* 监听明细选择数据 */
			uni.$once('select',function(data){
				data.forEach((item,index)=>{
					_this.countPdlist.push(item)
				})
				uni.$off('select')
			})
			uni.navigateTo({
				url: '/pages/work/OnlineOrder/addProductDetails'
			});
		},
```

##### 8、页面跳转，并且携带参数 [官方地址](https://uniapp.dcloud.io/api/router?id=navigateto)

```
// 注意：调用 navigateTo 跳转时，调用该方法的页面会被加入堆栈，而 redirectTo 方法则不会。见下方示例代码

// 此处是A页面
uni.navigateTo({
    url: 'B?id=1'
});

// 此处是B页面
uni.navigateTo({
    url: 'C?id=1'
});

// 在C页面内 navigateBack，将返回A页面
uni.navigateBack({
    delta: 2
});


```

##### 9、js深拷贝 [参考文章](https://blog.csdn.net/fungleo/article/details/54931379)

```
var obj = {
  name: 'FungLeo',
  sex: 'man',
  old: '18'
}
var obj2 = JSON.parse(JSON.stringify(obj))
```

##### 10、数组

```
array.spilce(index,1)//删除索引index的元素
```

##### 11、js switch case语句

```
switch (表达式){
    case value1:
        statements1  // 当表达式的结果等于 value1 时，则执行该代码
        break;
    case value2:
        statements2  // 当表达式的结果等于 value2 时，则执行该代码
        break;
    ......
    case valueN:
        statementsN  // 当表达式的结果等于 valueN 时，则执行该代码
        break;
    default :
        statements  // 如果没有与表达式相同的值，则执行该代码
}
```

##### 12、深度监听某数组对象里面数据变化

```
watch: {
		countPdlist: function(){
			let quantity = 0
			let amount = 0
			this.tableHeadList.forEach((item,index)=> {
				this.countPdlist.forEach((item2,index2)=>{
					switch(item.name){
						case "库存数量":
						  quantity += Number(item2.columns[index])
						case "库存重量":
						  amount += Number(item2.columns[index])
							break
					}
				})
			})
			this.$set(this.formData,'zsl',quantity)
			this.$set(this.formData,'zdw',amount.toFixed(2))
		},
		deep:true
	},
```

##### 13、请求数据格式请求头

```
header: {
				'zsgt': constant.getWebToken(),
				'tenantName': constant.getTenantName(),
				'Content-Type': params.contentType == null?'application/x-www-form-urlencoded':params.contentType,
			},
```

##### 14、下拉停止刷新

[官方介绍](https://uniapp.dcloud.io/api/ui/pulldown?id=stoppulldownrefresh)

```
uni.stopPullDownRefresh()
```

问题

- 查询列表，只有主表信息且全是代码，要怎么获取数据（后台修改）

- 修改引入产品数量，重量是按照什么来变，数量为1 重量是多少，单价是多少

##### 16、uni-table实现表头固定(记得要给其父元素添加一个相对定位)

```
/deep/ .uni-table-th[data-v-511e81f9] {
		padding: 6px 10px;
		background-color: #f4f7fd;
		position: sticky;
		top: 0px;
	}
```

##### 17、uni-app 移动端无法深度监听数据变化

[官方介绍](https://uniapp.dcloud.io/vue-basics?id=%e4%be%a6%e5%90%ac%e5%99%a8watch)

```
watch: {
		tableData: {
			handler: function(val,oldVal){
			let quantity = 0
			let amount = 0
			let price = 0
			this.tableData.forEach((item,index)=>{
				quantity += Number(item.cpsl)
				amount += Number(item.cpzl)
				// price += Number(item.cpdj) * Number(item.cpzl)
				price += Number(item.cpdj * item.cpzl)
			})
			this.$set(this.formData,'zsl',quantity)
			this.$set(this.formData,'zdw',amount.toFixed(2))
			this.$set(this.formData,'zje',price.toFixed(2))
		  },
			deep:true
		}
	},
```

##### 18、uni-app提示框

[参考文章](https://cloud.tencent.com/developer/article/1711052)

```
uni.showToast({
					title: '请先选择仓库',
					icon:'none',
					duration: 1000
				});
```

##### 19、显示提示框后再页面跳转

```
	uni.showToast({
							title: '修改成功!',
							duration: 500
						});
						setTimeout(() => {
							uni.hideToast();
							//关闭提示后跳转
							uni.navigateTo({
								url:'/pages/work/OnlineOrder/OnlineOrder'
							})
						}, 500)
```

##### 20、`HM-dragSorts` 拖拽插件

[地址](https://ext.dcloud.net.cn/plugin?id=1372)

##### 21、uni-app中的#ifdef #ifndef #endif的用处，可以处理兼容多端平台

[参考地址](https://blog.csdn.net/weixin_41891519/article/details/104365609)

#### 填坑

#### 1、pc端和app端的样式不一致

场景：使用的 /deep/ 修改组件样式，在app端没有显示,但是在pc端调试能显示

解决：

方式一：直接到组件内部样式修改（这样的话，不同的人发布的代码，可能会有问题，从长远看，不太可取）

方式二：



### git

#### git基本操作

<img src="https://img2020.cnblogs.com/blog/2062129/202109/2062129-20210902180150046-76513691.png" alt="img"  />

- git init 命令来初始化一个 Git 仓库
- git clone 我们使用 git clone 从现有 Git 仓库中拷贝项目
  [![img](https://img2020.cnblogs.com/blog/2062129/202109/2062129-20210902175655125-1140339448.png)](https://img2020.cnblogs.com/blog/2062129/202109/2062129-20210902175655125-1140339448.png)
  workspace：工作区
  staging area：暂存区/缓存区
  local repository：版本库或本地仓库
  remote repository：远程仓库

```
git init - 初始化仓库。
git add . - 添加文件到暂存区。
git commit - 将暂存区内容添加到仓库中。
```

#### [push](https://www.cnblogs.com/ff-upday/p/15030778.html)到github中时被拒绝（rejected）error: failed to push some refs _

#### [git中Please enter a commit message to explain why this merge is necessary.](https://www.cnblogs.com/wei325/p/5278922.html)

**Please enter a commit message to explain why this merge is necessary.**

**请输入提交消息来解释为什么这种合并是必要的**

![img](https://images2015.cnblogs.com/blog/630011/201603/630011-20160315120522896-1718649799.jpg)

git 在pull或者合并分支的时候有时会遇到这个界面。可以不管(直接下面3,4步)，如果要输入解释的话就需要:

1.按键盘字母 i 进入insert模式

2.修改最上面那行黄色合并信息,可以不修改

3.按键盘左上角"Esc"

4.输入":wq",注意是冒号+wq,按回车键即可

#### git 修改用户名以及提交邮箱

接手同事电脑，并且在其电脑上提交修改，当时在gitLab中却却显示是同事的提交

[参考文章](https://www.cnblogs.com/shenxiaolin/p/7896489.html)

```
查看用户名和邮箱地址：

$ git config user.name

$ git config user.email

修改用户名和邮箱地址

$  git config --global user.name  "xxxx"

S  git config --global user.email  "xxxx"
```

#### git更新

```
git update-git-for-windows
```

#### 删除远程分支

````
git push origin --delete 远程分支名
````



### 项目

#### eslint报错

> 开发时，禁用eslint 新建 vue.config.js 文件

```
module.exports={
  lintOnSave:false,
}
```

#### 序列化参数 qs

https://zhuanlan.zhihu.com/p/49029440
qs数据处理 https://github.com/ljharb/qs

JSON.stringify() 方法将一个 JavaScript 对象或值转换为 JSON 字符串

#### [什么是UUID](https://www.jianshu.com/p/da6dae36c290)

UUID 是指Universally Unique Identifier，翻译为中文是通用唯一识别码

#### [域名解析](https://www.npmjs.com/package/psl) psl

psl.parse(document.domain)

修改vscode配置，不要自动保存

#### 克隆对象函数

```

/** 返回克隆后的对象 */
    MixinClone(obj) {
      return JSON.parse(JSON.stringify(obj))
    },
```

#### 点击回车登录

注意！！！
elementUI 中 el-input监听键盘事件失效的原因
由于elementUI组件外层都包裹着一层div 所以需要使用修饰符 .native
[vue中监听键盘事件](https://blog.csdn.net/xiaxiangyun/article/details/80404768)
[vue全局监听键盘事件](https://blog.csdn.net/weixin_41192489/article/details/117431829)
[关于键盘事件与可聚焦元素（Focusable Elements）的问题](https://juejin.cn/post/6844903560530903054)

```
<el-input @keyup.enter.native="handleKeyUp" v-model="loginForm.pwd_num" placeholder="请输入密码" show-password>
   <template slot="prepend"><i class="el-icon-lock"></i></template>
</el-input>
```

```
 /* 点击回车直接登录 */
      handleKeyUp(event){
        console.log(event)
        if(event.keyCode === 13){
          this.funcLogin()
        }
      },
```

全局监听键盘点击事件
在mounted中调用

```
mounted() {
      this.handleKeyDown()
    },
```

注意this指向

```
/* 全局监听键盘点击事件 */
      handleKeyDown(){
        const this_=this
        document.addEventListener("keydown",function(e){
          if(e.keyCode === 13){
            if(this_.module==='login'){
              this_.funcLogin()
            } else {
              this_.funcCompany()
            }
          }
       })
      }
```

#### [Day.js](https://dayjs.fenxianglu.cn/)

> Day.js是一个极简的JavaScript库，可以为现代浏览器解析、验证、操作和显示日期和时间。

- 引入

```
// 引入DayJs
import dayjs from 'dayjs'
Vue.prototype.$dayjs = dayjs
```

- 使用

```
 time: this.$dayjs().format('YYYY-MM-DD HH:mm:ss'),
 time: this.$dayjs(1318781876406).format('YYYY-MM-DD HH:mm:ss'),
 time:this.$dayjs.unix(1318781876).format('YYYY-MM-DD HH:mm:ss'),
```

#### @wheel.prevent="handleScroll"

- @wheel vue中监听滚轮事件
- prevent 阻止默认事件
  [事件修饰符](https://cn.vuejs.org/v2/guide/events.html#事件修饰符)
- [offsetWidth](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/offsetWidth)
  返回一个元素的布局宽度，包含元素的边框（border）、水平线上的内边距，以及css设置的宽度（width）的值
- 鼠标滚动事件的属性
  eventDelta 判断鼠标滚动的方向，如果大于0则是鼠标往下滑 标签栏往右移
  如果是小于0的话，就是鼠标往上滑，标签栏往左移

#### 前端金额精度问题
[![img](https://img2020.cnblogs.com/blog/2062129/202109/2062129-20210923084437173-2118127658.png)](https://img2020.cnblogs.com/blog/2062129/202109/2062129-20210923084437173-2118127658.png)
解决：保留两位小数 第二位为0时，不显示
`Number((1.27+1.45).toFixed(2))`

#### 输入金额限制输入三位小数
项目自定义指令：v-only-number="3"

#### 缓存

Cookie

Web Storage

sessionStorage

为每个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用（只要浏览器打开的状态，包括页面重新加载和恢复）
[MDN 介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage)

localStorage

同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。
localStorage

[MDN介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/Storage)

#### 状态管理器store

state
getters: 相当于computed计算属性
mutations
actions
modules

#### vue+elementUI引入第三方图标

以[阿里巴巴矢量图标库](https://www.iconfont.cn/)为例
1.新建一个项目
[![img](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112328568-215157604.png)](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112328568-215157604.png)

2.填写项目相关信息 可以自由设置字体图标的前缀
[![img](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112508016-1361447869.png)](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112508016-1361447869.png)

3.搜索你需要的图标 添加入库
[![img](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112718251-285219305.png)](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112718251-285219305.png)

4.添加至项目 （添加到你创建的那个项目）
[![img](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112813910-662190070.png)](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112813910-662190070.png)

5.点击复制代码
[![img](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112918261-98879005.png)](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008112918261-98879005.png)

6.到自己的项目中，新建一个 iconfont.css 文件，把复制的内容粘贴进去 保存
7.到 main.js 中引入 iconfont.css文件
例如： `import './iconfont.css' //第三方图标`
8.使用
[![img](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008113436516-1526777042.png)](https://img2020.cnblogs.com/blog/2062129/202110/2062129-20211008113436516-1526777042.png)
注意： iconfont不能少， 还有 icon- 创建项目时，自己或者默认设置的前缀

#### 获取用户ip地址

```
<script src="http://pv.sohu.com/cityjson?ie=utf-8"></script>
<script> 
  document.write(returnCitySN["cip"]+','+returnCitySN["cname"])
</script>
```

bs文件流导出excel文件

```
<el-button size="small" icon="el-icon-download" style="float: right; margin-right:10px;" @click="handleExport">导出</el-button>
```

```
/* 导出查询结果 */
      handleExport() {
        this.loading = true
        if (this.params.createDate_range) {
          this.params.startTime = this.params.createDate_range[0]
          this.params.endTime = this.params.createDate_range[1]
        } else {
          this.params.startTime = ''
          this.params.endTime = ''
        }
        if (this.params.documentDate_range) {
          this.params.documentStartTime = this.params.documentDate_range[0]
          this.params.documentEndTime = this.params.documentDate_range[1]
        } else {
          this.params.documentStartTime = ''
          this.params.documentEndTime = ''
        }
        let fn = this.listType === '单据' ? 'exportContractList' : 'exportPurchaseDetailList'
        let params = this.MixinClone(this.params)
        if (this.listType === '单据') {
          delete params.productName
          delete params.material
          delete params.spec
          delete params.origin
          delete params.warehouseNum
          delete params.warehouseId
          delete params.positions
        }
        API_Purchase[fn](params).then(response => {
          this.loading = false
          const link = document.createElement("a");
          let blob = new Blob([response], { type: "application/vnd.ms-excel" });//生成blob对象
          link.style.display = "none";
          link.href = URL.createObjectURL(blob);
          let title = this.listType === '单据' ? '采购合同列表' : '采购合同明细列表列表'
          link.setAttribute("download", title + ".xlsx"); //下载的文件名以及文件格式
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }).catch(() => { this.loading = false })
      },
```

#### 有些页面只执行mounted却不执行activated函数？

原因：页面的name值与路由的name不一致

#### 全局刷新页面再关闭所有标签，当前标签并未关闭

打开某一页面 全局刷新 右键标签栏关闭所有

出现问题：当前标签并未关闭？

原因：

> 该方法存在异步操作

```
closeAllTags() {
        this.$store.dispatch('delAllViews')
        this.$router.push('/home/dashboard')
        let _this = this
        setTimeout(function(){
          _this.addViewTags()
        },0)
      },
```



### Echarts

#### options 配置

```
initCharts() {
      // 基于准备好的dom，初始化echarts实例
      var myChart = echarts.init(document.getElementById('profit'));
      let option = {
        title:{
          text:'商品利润',
          textStyle:{
            color:'#fff'
          }
        },
        tooltip: {
          trigger: 'item',
          formatter: '{a} <br/>{b}: {c} ({d}%)'
        },
        legend: {
          show:true,
          
        },
        series: [
          {
            name: '亏损',
            type: 'pie',
            // selectedMode: 'single',
            radius: [0, '30%'],
            label: {
              position: 'inner',
              fontSize: 14
            },
            labelLine: {
              show: false
            },
            data: [
              { value: -29.191, name: '螺纹钢' },
              { value: -24759.774, name: 'C料' },
              { value: -2214, name: 'B料'},
              { value: -105.39, name: 'D料'},
            ]
          },
          {
            name: '盈利',
            type: 'pie',
            radius: ['30%', '60%'],
           
            data: [
              { value: 0, name: '等脚边' },
              { value: 335, name: '不等脚边' },
              { value: 310, name: '双等脚边' },
              // { value: 251, name: 'Google' },
              // { value: 234, name: 'Union Ads' },
              // { value: 147, name: 'Bing' },
              // { value: 135, name: 'Video Ads' },
              // { value: 102, name: 'Others' }
            ]
          }
        ]
      };
      // 使用刚指定的配置项和数据显示图表。
      myChart.setOption(option);
    }

```

#### legend 图例

[tooltip](https://echarts.apache.org/zh/option.html#legend.tooltip)

```
legend:{
  tooltip:{
    show:true
  }
}
```

#### lable

[formatter](https://echarts.apache.org/zh/option.html#series-pie.label.formatter)

```
label: {
  position: 'inner',
  fontSize: 14,
  textStyle:{
    color:'#fff',
    borderColor:false,
    fontSize:10
  },
  formatter:function(params) {
    var res = params.name
    /* 如果占比小于20%时 */
    if(params.percent<=0.2) {
      // res = res.substring(0,2) + ".."  //过长显示省略号
      res = '' //直接不显示lable
    }
    return res
  },
},
```

#### series

```
series:{
  // center:['50%', '40%'], //饼图位置
  radius: ['30%', '60%'],
  selectedMode: 'single', //选中突出
},
```

#### [yAxis](https://echarts.apache.org/examples/zh/editor.html?c=multiple-y-axis)

#### tooltip

```
tooltip:{
  trigger: 'axis', //坐标轴触发，主要在柱状图，折线图等会使用类目轴的图表中使用。
  axisPointer: {
    type: 'cross' //'cross' 十字准星指示器。其实是种简写，表示启用两个正交的轴的 axisPointer。
  }
}
```

#### xAxis

修改x轴过于密集

```
axisLabel: {
  interval: 0,
  rotate: 35
}

//刻度标签旋转的角度，在类目轴的类目标签显示不下的时候可以通过旋转防止标签之间重叠。
//旋转的角度从 -90 度到 90 度。
```







#### 解决数据差过大的问题

```
yAxis:{
  type: 'log',
  min: 1,
  logBase: 10
},
```

![image-20220113110824899](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220113110824899.png)

#### [Echarts图表不显示](https://www.cnblogs.com/ff-upday/p/15429923.html)

#### echart series label 属性失效

[参考文章](https://www.jianshu.com/p/4fb6e0bc4af2)

![image-20211221105858327](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20211221105858327.png)

```
label: {
  normal: {
    show: true,
    position: 'inside',
    formatter: '{d}%'
  }
  },
```

```
option = {
  series: {
    type: 'scatter',

    // 普通样式。
    itemStyle: {
      // 点的颜色。
      color: 'red'
    },
    label: {
      show: true,
      // 标签的文字。
      formatter: 'This is a normal label.'
    },

    // 高亮样式。
    emphasis: {
      itemStyle: {
        // 高亮时点的颜色。
        color: 'blue'
      },
      label: {
        show: true,
        // 高亮时标签的文字。
        formatter: 'This is a emphasis label.'
      }
    }
  }
};
```

#### 双柱状图单选，模式

```
legend:{
          align: 'left',
          right: 20,
          textStyle:{
            color:'skyblue'
          },
          selectedMode:'single', //单选模式
          selected: {
            // '开单量': true,
            '成交量': false //初始不选中
          }
        },
```

#### echarts线性渐变

```
//饼图渐变
data () {
let color1 = new echarts.graphic.LinearGradient(0,1,0,0,[{ offset: 0, color: "#cee7ff" }, { offset: 1, color: "#148afe" }],false);
let color2 = new echarts.graphic.LinearGradient(0,1,0,0,[{ offset: 0, color: "#70d0fe" }, { offset: 1, color: "#afe5ff" }],false);
let color3 = new echarts.graphic.LinearGradient(0,1,0,0,[{ offset: 0, color: "#17c0e0" }, { offset: 1, color: "#f59311" }],false);
		  
return {
  chartData: {},
  chartSettings: {
    label: {
      normal: {  
        show: true,
        position: 'inside',
        formatter: '{d}%'
      }
    }
  },
  chartExtend:{
    // color: ['#96e0e0','#EDB2B2','#74AEE8'],
    color:[color1,color2,color3]}
```

```
//柱状图渐变
chartExtend: {
  color:[{
    type: 'linear',
    x: 0,
    y: 0,
    x2: 0,
    y2: 1,
    colorStops: [{
      offset: 0, color: '#FFFF00' // 0% 处的颜色
    }, {
      offset: 1, color: '#FFCC00' // 100% 处的颜色
    }],
    global: false // 缺省为 false
  },]
 }
```



#### V-Charts中使用toolbox工具

```
chartExtend: {
        color: ['#c0504d','#4f81bd'],
        legend:{
          show: false
        },
        title:{
          // text:'应收',
          textStyle:{
            color: '#fff'
          }
        },
        toolbox: {
          show:true,
          feature: {
            saveAsImage:{
              show:true
            }
          }
        },
```

开始的时候没有效果

解决：在main.js文件中引入toolbox

```
Vue.use(VCharts)
import "echarts/lib/component/title"
import "echarts/lib/component/toolbox"
```

### 折线图

#### markPoint折线图显示标注

```
//首先在main.js中引入标注
import "echarts/lib/component/markPoint" //引入标注
```

```
markPoint: {
  data: [
    { type: 'max', name: 'Max' },
    { type: 'min', name: 'Min' }
   ],
   itemStyle:{
    //  color:'skyblue'
   }
},
 markLine: {
   data: [{ type: 'average', name: 'Avg' }]
 }
```



### 柱状图

#### 修改柱状图形状

```
series:{
  itemStyle:{
    borderWidth:2,
    barBorderRadius: [5,5,0,0] //修改四个角的弧度
  },
  type:'bar',
  barWidth: 15, //柱状图宽度
  barGap:0 //双柱状图的间隔
}
```

#### 数据过多时实现横向滚动 dataZoom

```
dataZoom:[{
  // type:'inside',
  type:'slider',
  show:true,
  start:0,
  end:50,
  textStyle:{
    color:'#fff'
  },
  dataBackground: {
    lineStyle: {
      color:"red"
    },
    areaStyle: {
      color: '#fff'
    }
  } }],
```

#### 条形图名称太长显示省略号

```
yAxis:{
  axisLabel:{
  show: true,
  interval: 0,
  textStyle: {
    color: '#fff',
    fontSize: 14
  },
  formatter: function(value) {
    var res = value
    if(res.length > 5) {
      res = res.substring(0,4) + ".."
    }
    return res
  }
}
},
```

![image-20220111174606891](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220111174606891.png)

#### 柱状图数据相差太大显示问题

使用柱状图发现数据相差太大，导致图表显示出现问题

解决：

> 在echarts里发现一种和饼图相似的径向图，设置最大的刻度。勉强能实现，但这种径向图更适合数据过多的时候，要是相互之间数据差额过大的话，现在想到的只有设置一个最大值，保证最小值能显示出来

![image-20220112115352104](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220112115352104.png)

> 方式二： 还是换种图吧，dataV里面的排名轮播图就挺好的

> 方式三：柱状图和折线图可以使用 log轴 ,饼图使用minAngle：0-360最小角度
>
> ```
> yAxis:{
>   type: 'log',
>   min:1,
>   logBase: 10
> },
> ```

<img src="D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220113111508055.png" alt="image-20220113111508055" style="zoom:80%;" />

成功解决！！！

> 方式四  使用dataZoom缩放也可以诶
>
> [官方地址](https://echarts.apache.org/examples/zh/editor.html?c=mix-zoom-on-value&lang=js)

```
dataZoom: [
  {
    show: true,
    start: 94,
    end: 100
  },
  {
    type: 'inside',
    start: 94,
    end: 100
  },
  {
    show: true,
    yAxisIndex: 0,
    filterMode: 'empty',
    width: 30,
    height: '80%',
    showDataShadow: false,
    left: '93%'
  } ],
```



```
initChart() {
      let myChart = echarts.init(document.getElementById('countReceive'))
      let option = {
        color:[
          {
          type: 'linear',
          x: 0,
          y: 0,
          x2: 0,
          y2: 1,
          colorStops: [{
            offset: 0, color: '#FFFF00' // 0% 处的颜色
          }, {
            offset: 1, color: '#ffff33' // 100% 处的颜色
          }],
          global: false // 缺省为 false
        },
        {
          type: 'linear',
          x: 0,
          y: 0,
          x2: 0,
          y2: 1,
          colorStops: [{
            offset: 0, color: '#00ff00' // 0% 处的颜色
          }, {
            offset: 1, color: '#00ff66' // 100% 处的颜色
          }],
          global: false // 缺省为 false
        }],
        title: [
          {
            text: '收款总额排名',
            textStyle:{
              color:'#fff'
            }
          }
        ],
        textStyle:{
          color:'#fff'
        },
        polar: {
          radius: [30, '80%']
        },
        angleAxis: {
          max: 100, //设置最大值
          startAngle: 0,
          // min:'dataMin',
        },
        radiusAxis: {
          type: 'category',
          data: ['a', 'b', 'c', 'd'],
          triggerEvent:true
        },
        tooltip: {},
        series: {
          type: 'bar',
          data: [2, 2545863, 4.5, 36],
          coordinateSystem: 'polar',
          label: {
            show: true,
            position: 'middle',
            formatter: '{b}: {c}'
          }
        }
      };
      option && myChart.setOption(option);
    }
```

### 饼图

####  文字过长重叠

```
minAngle:0-360 //设置一个最小的角度
```

但是交互就会有问题，本来相差很大可以直观从图里看出来，当时设置了一个最小角度，让用户看起来就觉得相差不大了，需要添加一个提示

#### 使用formatter函数，修改小于某个角度就不显示lable

```
label: {
  position: 'inner',
  fontSize: 14,
  textStyle:{
    color:'#fff',
    borderColor:false,
    fontSize:10
  },
  formatter:function(params) {
    var res = params.name
    /* 如果占比小于20%时 */
    if(params.percent<=0.2) {
      // res = res.substring(0,2) + ".."  //过长显示省略号
      res = '' //直接不显示lable
    }
    return res
  },
},
```



#### 饼图部分负值如何显示

方式一：

嵌套饼图，数据格式需要把所有的负值放在里面的饼，正值放在外层，数据处理可能麻烦些

![image-20220112104930503](D:\FfWork\notes\实战填坑\踩坑记录.assets\image-20220112104930503.png)

```
initCharts() {
       // 基于准备好的dom，初始化echarts实例
      var myChart = echarts.init(document.getElementById('profit'));
      let option = {
        title:{
          text:'商品利润',
          textStyle:{
            color:'#fff'
          }
        },
        tooltip: {
          trigger: 'item',
          formatter: '{a} <br/>{b}: {c} ({d}%)'
        },
        legend: {
          show:true,
          type:'scroll',
          selectedMode:false,
          textStyle:{
            color:'#fff'
          },
          // orient:'vertical',
          // right:0,
          top: 25,
          align:'right',
          tooltip:{
            show:true
          }
        },
        series: [
          {
            name: '亏损',
            type: 'pie',
            // selectedMode: 'single',
            minAngle:50, //设置起始度数
            radius: [0, '30%'],
            label: {
              position: 'inner',
              fontSize: 14,
              textStyle:{
                color:'#fff',
                borderColor:false,
                fontSize:10
              },
              formatter:function(params) {
                var res = params.name
                /* 如果占比小于20%时 */
                if(params.percent<=0.2) {
                  // res = res.substring(0,2) + ".."  //过长显示省略号
                  res = '' //直接不显示lable
                }
                return res
              },
            },
            labelLine: {
              show: false
            },
            data: [
              { value: -29.191, name: '螺纹钢' },
              { value: -24759.774, name: 'C料' },
              { value: -2214, name: 'B料'},
              { value: -105.39, name: 'D料'},
            ]
          },
          {
            name: '盈利',
            type: 'pie',
            radius: ['30%', '60%'],
            minAngle:10,
            data: [
              { value: 0, name: '等脚边' },
              { value: 335, name: '不等脚边' },
              { value: 310, name: '双等脚边' },
              { value: 25123, name: 'Google' },
              { value: 234, name: 'Union Ads' },
              { value: 147, name: 'Bing' },
              { value: 135, name: 'Video Ads' },
              { value: 1020, name: 'Others' }
            ]
          }
        ]
      };
      // 使用刚指定的配置项和数据显示图表。
      myChart.setOption(option);
    }
```



方式二：

使用径向柱状图，但是不能有百分比，数据好处理些



#### 饼图数据过多，占比太小显示问题

思考：

- 可以使用复合图，但是官方并没有这种示例

- 设置一个最小角度，看起来好些了，但是还是label会重叠，不太可行
- 看到旭日图，发现可以使用旭日图来展示，其它类有一个子级包含其它中的所用种类
- 



```
path.resolve
```

